#!/usr/bin/env bash
# Helper to update .gitignore with generated paths
# Only touches content between specific markers

# Update .gitignore with a list of paths
# Usage: update_gitignore "path/to/.gitignore" "path1 path2 path3 ..."
update_gitignore() {
    local gitignore_file="$1"
    local paths_string="$2"
    
    # Define markers
    local start_marker="# --- AI SYNC GENERATED START ---"
    local end_marker="# --- AI SYNC GENERATED END ---"
    
    # Ensure .gitignore exists
    if [[ ! -f "$gitignore_file" ]]; then
        touch "$gitignore_file"
    fi
    
    # Create the block content
    local new_block="$start_marker
# Automatically generated by .ai/sync/sync.sh
# Do not edit this block manually.
"
    
    # Append paths (sorted/deduplicated)
    if [[ -n "$paths_string" ]]; then
        # Convert space-separated string to newlines, sort, and append
        # Use simple echo + tr for compatibility
        local sorted_paths
        sorted_paths=$(echo "$paths_string" | tr ' ' '\n' | sort | uniq)
        new_block="${new_block}${sorted_paths}
"
    fi
    new_block="${new_block}${end_marker}"
    
    # Check if markers exist
    if grep -qF "$start_marker" "$gitignore_file"; then
        # Markers exist: replace content between them
        # Use perl for robust multiline replacement (sed is tricky across platforms with newlines)
        # We escape markers for regex
        local p_start=$(echo "$start_marker" | sed 's/[]\/$*.^[]/\\&/g')
        local p_end=$(echo "$end_marker" | sed 's/[]\/$*.^[]/\\&/g')
        
        # Read file content
        local content
        content=$(cat "$gitignore_file")
        
        # Replace block
        # Note: This simple perl approach works on most systems. 
        # Falls back to awkward awk/sed if perl is missing? most dev envs have perl.
        # Let's try a safer pure bash/sed approach if possible, or just overwrite the block.
        
        # Approach: 
        # 1. Read file line by line
        # 2. Print until start marker
        # 3. Print new block
        # 4. Skip lines until end marker
        # 5. Print remaining lines
        
        local temp_file="${gitignore_file}.tmp"
        local skip=0
        local found=0
        
        while IFS= read -r line || [[ -n "$line" ]]; do
            if [[ "$line" == "$start_marker" ]]; then
                echo "$new_block" >> "$temp_file"
                skip=1
                found=1
            elif [[ "$line" == "$end_marker" ]]; then
                skip=0
            elif [[ $skip -eq 0 ]]; then
                echo "$line" >> "$temp_file"
            fi
        done < "$gitignore_file"
        
        mv "$temp_file" "$gitignore_file"
        log_step "Updated .gitignore block"
        
    else
        # Markers do not exist: append to end
        echo "" >> "$gitignore_file"
        echo "$new_block" >> "$gitignore_file"
        log_step "Added generated block to .gitignore"
    fi
}
